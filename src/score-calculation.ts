/**\n * РАСЧЕТ ОЦЕНОК\n * \"Лестница союза\"\n *\n * Преобразование ответов тестирования в оценки личного уровня и уровня отношений\n * с применением валидационных коррекций\n */\n\nimport {\n  UserAnswer,\n  LevelScore,\n  UnionLevel,\n  ValidationMetrics,\n  TestResult,\n} from './types';\nimport { QUESTIONS } from './questions-database';\n\n// ============================================================================\n// КОНСТАНТЫ\n// ============================================================================\n\n// Вес для каждого типа вопроса\nconst QUESTION_WEIGHT: Record<string, number> = {\n  'zone-conflict-001': 2.0, // Зонирование - высокий вес\n  'zone-safety-002': 2.0,\n  'zone-growth-003': 1.8,\n  'zone-intimacy-004': 2.0,\n  'zone-choice-005': 2.0,\n  'zone-difference-006': 1.8,\n};\n\n// ============================================================================\n// ОСНОВНЫЕ ФУНКЦИИ РАСЧЕТА\n// ============================================================================\n\n/**\n * Рассчитать оценки уровней на основе ответов\n */\nexport function calculateLevelScores(\n  answers: UserAnswer[]\n): { personalLevel: number; relationshipLevel: number; levelScores: LevelScore[] } {\n  // Инициализировать счетчики для каждого уровня\n  const levelCounts = new Map<UnionLevel, { sum: number; weight: number; count: number }>();\n\n  for (let level: UnionLevel = 1; level <= 12; level++) {\n    levelCounts.set(level, { sum: 0, weight: 0, count: 0 });\n  }\n\n  // Обработать каждый ответ\n  answers.forEach((answer) => {\n    const question = QUESTIONS.find((q) => q.id === answer.questionId);\n    if (!question) return;\n\n    // Определить вес вопроса\n    const questionWeight =\n      QUESTION_WEIGHT[question.id] || (question.priority === 1 ? 1.5 : 1.0);\n\n    // Выбранный уровень\n    const selectedLevel = answer.selectedLevel;\n\n    // Добавить в счет для выбранного уровня\n    const current = levelCounts.get(selectedLevel)!;\n    current.sum += selectedLevel * questionWeight;\n    current.weight += questionWeight;\n    current.count++;\n\n    // Также добавить вклад в соседние уровни с убывающим весом\n    // Это представляет неопределенность\n    for (let level: UnionLevel = 1; level <= 12; level++) {\n      if (level === selectedLevel) continue;\n\n      const distance = Math.abs(level - selectedLevel);\n      const neighborWeight = Math.max(0, 1 - distance / 12) * questionWeight * 0.5;\n\n      if (neighborWeight > 0) {\n        const neighbor = levelCounts.get(level)!;\n        neighbor.sum += level * neighborWeight;\n        neighbor.weight += neighborWeight;\n      }\n    }\n  });\n\n  // Рассчитать средний уровень для каждого уровня\n  const levelScores: LevelScore[] = [];\n  let maxScore = 0;\n  let topLevel: UnionLevel = 6;\n\n  // Рассчитать средние оценки\n  const levelAverages = new Map<UnionLevel, number>();\n  levelCounts.forEach((data, level) => {\n    if (data.weight > 0) {\n      const avg = data.sum / data.weight;\n      levelAverages.set(level, avg);\n    }\n  });\n\n  // Найти максимум для нормализации\n  const maxAverage = Math.max(...Array.from(levelAverages.values()));\n\n  // Создать LevelScore с процентами и уверенностью\n  for (let level: UnionLevel = 1; level <= 12; level++) {\n    const avg = levelAverages.get(level) || 0;\n    const percentage = maxAverage > 0 ? (avg / maxAverage) * 100 : 0;\n\n    // Уверенность зависит от количества ответов\n    const count = levelCounts.get(level)!.count;\n    const confidence = Math.min(1, count / (answers.length * 0.3));\n\n    levelScores.push({\n      level,\n      percentage: Math.round(percentage),\n      confidence,\n    });\n\n    if (percentage > maxScore) {\n      maxScore = percentage;\n      topLevel = level;\n    }\n  }\n\n  // Рассчитать плавающий личный уровень (1-12 с точностью 0.1)\n  let personalLevel = calculateFloatingLevel(levelAverages);\n\n  // Уровень отношений обычно рассчитывается как личный уровень\n  // (в реальной системе это может быть отдельный расчет)\n  let relationshipLevel = personalLevel;\n\n  // Если это оценка партнера, это может быть интерпретировано иначе\n  // Но здесь мы используем ту же логику\n\n  return {\n    personalLevel: Math.round(personalLevel * 10) / 10,\n    relationshipLevel: Math.round(relationshipLevel * 10) / 10,\n    levelScores,\n  };\n}\n\n/**\n * Рассчитать плавающий уровень (1-12 с точностью 0.1)\n * На основе взвешенного среднего\n */\nfunction calculateFloatingLevel(\n  levelAverages: Map<UnionLevel, number>\n): number {\n  let totalScore = 0;\n  let totalWeight = 0;\n\n  levelAverages.forEach((avg, level) => {\n    totalScore += level * avg;\n    totalWeight += avg;\n  });\n\n  if (totalWeight === 0) {\n    return 6; // Центральное значение по умолчанию\n  }\n\n  const floatingLevel = totalScore / totalWeight;\n\n  // Убедиться что уровень в пределах 1-12\n  return Math.max(1, Math.min(12, floatingLevel));\n}\n\n/**\n * Применить коррекции валидации к результатам\n */\nexport function applyValidationAdjustments(\n  personalLevel: number,\n  relationshipLevel: number,\n  validation: ValidationMetrics\n): { personalLevel: number; relationshipLevel: number } {\n  let adjustedPersonal = personalLevel;\n  let adjustedRelationship = relationshipLevel;\n\n  // Коррекция на основе социальной желательности\n  // Если высокий социальный имидж, немного снизить оценку\n  if (validation.socialDesirabilityScore > 0.6) {\n    // Сдвинуть на 0.5-1.0 вниз\n    const adjustment = (validation.socialDesirabilityScore - 0.6) * 2;\n    adjustedPersonal = Math.max(1, adjustedPersonal - adjustment);\n    adjustedRelationship = Math.max(1, adjustedRelationship - adjustment);\n  }\n\n  // Коррекция на основе противоречий\n  // Каждое противоречие снижает уровень на 0.2\n  if (validation.contradictionFlags.length > 0) {\n    const adjustment = validation.contradictionFlags.length * 0.2;\n    adjustedPersonal = Math.max(1, adjustedPersonal - adjustment);\n  }\n\n  // Коррекция на основе духовного байпаса\n  // Если есть духовный байпас, снизить высокие уровни\n  if (validation.spiritualBypassScore > 0.6) {\n    if (adjustedPersonal >= 10) {\n      const adjustment = (validation.spiritualBypassScore - 0.6) * 3;\n      adjustedPersonal = Math.max(8, adjustedPersonal - adjustment);\n    }\n  }\n\n  // Коррекция на основе когерентности\n  // Низкая когерентность означает нестабильность\n  if (validation.coherenceScore < 40) {\n    // Снизить уровень и добавить неопределенность\n    adjustedPersonal = Math.max(1, adjustedPersonal - 1);\n  }\n\n  // Убедиться что уровни в пределах 1-12\n  adjustedPersonal = Math.max(1, Math.min(12, adjustedPersonal));\n  adjustedRelationship = Math.max(1, Math.min(12, adjustedRelationship));\n\n  return { personalLevel: adjustedPersonal, relationshipLevel: adjustedRelationship };\n}\n\n// ============================================================================\n// ПУБЛИЧНЫЙ API\n// ============================================================================\n\n/**\n * Рассчитать полные результаты теста\n */\nexport function calculateTestResult(\n  sessionId: string,\n  answers: UserAnswer[],\n  validation: ValidationMetrics,\n  testMode: any,\n  relationshipStatus: any\n): Omit<TestResult, 'createdAt' | 'updatedAt'> {\n  // Рассчитать базовые оценки\n  const { personalLevel, relationshipLevel, levelScores } = calculateLevelScores(answers);\n\n  // Применить коррекции валидации\n  const { personalLevel: adjustedPersonal, relationshipLevel: adjustedRelationship } =\n    applyValidationAdjustments(personalLevel, relationshipLevel, validation);\n\n  // Рассчитать время выполнения\n  const completionTime =\n    answers.length > 0\n      ? answers[answers.length - 1].timestamp - answers[0].timestamp\n      : 0;\n\n  const now = Date.now();\n\n  return {\n    sessionId,\n    testMode,\n    relationshipStatus,\n    personalLevel: adjustedPersonal,\n    relationshipLevel: adjustedRelationship,\n    levelScores,\n    validation,\n    answers,\n    totalQuestions: answers.length,\n    completionTime,\n    createdAt: now,\n    updatedAt: now,\n  };\n}\n\n/**\n * Рассчитать совместимость между двумя результатами\n */\nexport function calculateCompatibility(\n  personalLevel1: number,\n  personalLevel2: number\n): number {\n  const gap = Math.abs(personalLevel1 - personalLevel2);\n\n  // Совместимость снижается с расстоянием\n  let compatibility = 100 - gap * 10;\n\n  // Бонус если оба на зрелом уровне (7+)\n  if (personalLevel1 >= 7 && personalLevel2 >= 7) {\n    compatibility = Math.min(100, compatibility + 15);\n  }\n\n  // Штраф если оба на низком уровне (3 и ниже)\n  if (personalLevel1 <= 3 && personalLevel2 <= 3) {\n    compatibility = Math.max(0, compatibility - 20);\n  }\n\n  // Штраф если есть экстремальная разница\n  if (gap >= 4) {\n    compatibility = Math.max(0, compatibility - 10);\n  }\n\n  return Math.max(0, Math.min(100, compatibility));\n}\n\n/**\n * Рассчитать индекс надежности результата\n */\nexport function calculateReliabilityScore(\n  validation: ValidationMetrics\n): number {\n  let score = 100;\n\n  // Снизить за социальную желательность\n  score -= validation.socialDesirabilityScore * 30;\n\n  // Снизить за противоречия\n  score -= validation.contradictionFlags.length * 10;\n\n  // Снизить за духовный байпас\n  score -= validation.spiritualBypassScore * 20;\n\n  // Учесть когерентность\n  score -= (100 - validation.coherenceScore) * 0.3;\n\n  // Убедиться что в пределах 0-100\n  return Math.max(0, Math.min(100, score));\n}\n\n/**\n * Сгенерировать рекомендацию по надежности\n */\nexport function getReliabilityRecommendation(\n  validation: ValidationMetrics\n): string[] {\n  const recommendations: string[] = [];\n\n  if (validation.socialDesirabilityScore > 0.6) {\n    recommendations.push(\n      'Старайтесь быть честнее в следующих ответах - социальный имидж может искажать результаты'\n    );\n  }\n\n  if (validation.contradictionFlags.includes('conditional-love')) {\n    recommendations.push(\n      'Обратите внимание на противоречие между заявленной любовью и попытками контролировать партнера'\n    );\n  }\n\n  if (validation.contradictionFlags.includes('spiritual-bypass')) {\n    recommendations.push(\n      'Проверьте не используете ли вы духовность чтобы избежать реальной работы над отношениями'\n    );\n  }\n\n  if (validation.coherenceScore < 50) {\n    recommendations.push(\n      'Ваши ответы не очень согласованны - возможно, ваше поведение зависит от ситуации больше чем от убеждений'\n    );\n  }\n\n  if (validation.spiritualBypassScore > 0.5) {\n    recommendations.push(\n      'Будьте осторожны с духовным байпасом - высокие идеалы должны быть подкреплены практикой'\n    );\n  }\n\n  return recommendations;\n}\n\n/**\n * Получить распределение вероятности уровней в процентах\n */\nexport function getLevelDistribution(\n  levelScores: LevelScore[]\n): Record<number, number> {\n  const distribution: Record<number, number> = {};\n\n  levelScores.forEach((score) => {\n    distribution[score.level] = score.percentage;\n  });\n\n  return distribution;\n}\n"
