/**
 * АДАПТИВНЫЙ АЛГОРИТМ ОПРЕДЕЛЕНИЯ УРОВНЯ
 * "Лестница союза"
 *
 * Трёхфазный адаптивный тест:
 * 1. ЗОНИРОВАНИЕ (6 вопросов) - быстро определить зону 1-4, 5-8 или 9-12
 * 2. УТОЧНЕНИЕ (8-12 вопросов) - точно определить уровень в пределах зоны\n * 3. ВАЛИДАЦИЯ (3-4 вопроса) - подтвердить результат и обнаружить искажения
n *\n *총время: 15-20 минут (20-28 вопросов максимум)\n */\n\nimport { SmartQuestion, UnionLevel, UserAnswer } from './types';\nimport {\n  QUESTIONS,\n  getZoningQuestions,\n  getRefinementQuestions,\n  getValidationQuestions,\n  getQuestionsByTargetLevel,\n} from './questions-database';\n\n// ============================================================================\n// ТИПЫ\n// ============================================================================\n\nexport interface LevelDetection {\n  detectedLevel: number; // 1-12 с точностью до 0.1\n  confidence: number; // 0-1, уверенность в оценке\n  zone: 'low' | 'middle' | 'high'; // 1-4, 5-8 или 9-12\n  levelScoreDistribution: Map<UnionLevel, number>; // Распределение вероятности по уровням\n}\n\nexport interface QuestionSelection {\n  nextQuestion: SmartQuestion;\n  phase: 'zoning' | 'refinement' | 'validation' | 'complete';\n  questionsAnswered: number;\n  questionsRemaining: number;\n  estimatedLevelSoFar?: LevelDetection;\n}\n\nexport interface AdaptiveTestState {\n  sessionId: string;\n  answers: UserAnswer[];\n  currentPhase: 'zoning' | 'refinement' | 'validation' | 'complete';\n  detectedZone?: 'low' | 'middle' | 'high';\n  questionsAnswered: number;\n  questionsAsked: Set<string>; // Какие вопросы уже задавались\n  levelScores: Map<UnionLevel, number>; // Текущие расчёты уровней\n  testStartTime: number;\n}\n\n// ============================================================================\n// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ\n// ============================================================================\n\n/**\n * Начать адаптивный тест\n */\nexport function initializeAdaptiveTest(sessionId: string): AdaptiveTestState {\n  return {\n    sessionId,\n    answers: [],\n    currentPhase: 'zoning',\n    questionsAnswered: 0,\n    questionsAsked: new Set(),\n    levelScores: new Map(),\n    testStartTime: Date.now(),\n  };\n}\n\n/**\n * Определить зону по ответам зонирования\n * Возвращает наиболее вероятную зону (low=1-4, middle=5-8, high=9-12)\n */\nfunction detectZone(\n  zoneAnswers: Map<string, UnionLevel>\n): 'low' | 'middle' | 'high' {\n  const levels: UnionLevel[] = Array.from(zoneAnswers.values());\n  const avgLevel = levels.reduce((a, b) => a + b, 0) / levels.length;\n\n  if (avgLevel <= 4.5) return 'low';\n  if (avgLevel <= 8.5) return 'middle';\n  return 'high';\n}\n\n/**\n * Рассчитать точность по каждому уровню на основе ответов\n * Использует взвешенные очки с учетом целевых уровней вопроса\n */\nfunction calculateLevelScores(\n  answers: UserAnswer[],\n  questions: Map<string, SmartQuestion>\n): Map<UnionLevel, { score: number; confidence: number }> {\n  const levelScores = new Map<UnionLevel, { score: number; confidence: number }>();\n\n  // Инициализировать все уровни\n  for (let level: UnionLevel = 1; level <= 12; level++) {\n    levelScores.set(level, { score: 0, confidence: 0 });\n  }\n\n  // Обработать каждый ответ\n  answers.forEach((answer) => {\n    const question = questions.get(answer.questionId);\n    if (!question) return;\n\n    // Найти выбранный вариант ответа\n    const selectedOption = question.options.find(\n      (opt) => opt.id === answer.selectedOptionId\n    );\n    if (!selectedOption) return;\n\n    const selectedLevel = selectedOption.level;\n    const targetLevels = question.targetLevels;\n\n    // Рассчитать вес этого ответа для каждого уровня\n    // Максимальный вес если вопрос предназначен для этого уровня\n    // Убывающий вес по мере удаления от выбранного уровня\n    for (let level: UnionLevel = 1; level <= 12; level++) {\n      const current = levelScores.get(level)!;\n\n      // Базовый вес: попадает ли уровень в целевые уровни вопроса\n      let weight = targetLevels.includes(level) ? 1.0 : 0.3;\n\n      // Более высокий вес если ответ непосредственно указывает на этот уровень\n      if (selectedLevel === level) {\n        weight = 2.0;\n      }\n\n      // Снижение веса по мере удаления\n      const distance = Math.abs(level - selectedLevel);\n      const distancePenalty = Math.max(0, 1 - distance / 12);\n      weight *= distancePenalty;\n\n      // Добавить в итоговый счёт\n      current.score += weight;\n    }\n  });\n\n  // Нормализовать оценки и рассчитать уверенность\n  const totalScore = Array.from(levelScores.values()).reduce(\n    (sum, s) => sum + s.score,\n    0\n  );\n\n  if (totalScore > 0) {\n    Array.from(levelScores.values()).forEach((item) => {\n      item.confidence = item.score / totalScore; // 0-1\n      item.score = item.score / totalScore; // Нормализовать 0-1\n    });\n  }\n\n  return levelScores;\n}\n\n/**\n * Определить детектируемый уровень на основе текущих ответов\n */\nfunction detectCurrentLevel(\n  answers: UserAnswer[],\n  questions: Map<string, SmartQuestion>\n): LevelDetection {\n  const levelScores = calculateLevelScores(answers, questions);\n  const scores = Array.from(levelScores.entries());\n\n  // Найти уровень с наивысшим баллом\n  let maxScore = 0;\n  let topLevel: UnionLevel = 6;\n  let topConfidence = 0;\n\n  scores.forEach(([level, { score, confidence }]) => {\n    if (score > maxScore) {\n      maxScore = score;\n      topLevel = level;\n      topConfidence = confidence;\n    }\n  });\n\n  // Определить зону\n  let zone: 'low' | 'middle' | 'high';\n  if (topLevel <= 4) zone = 'low';\n  else if (topLevel <= 8) zone = 'middle';\n  else zone = 'high';\n\n  // Рассчитать плавающий уровень (1-12 с точностью 0.1)\n  // На основе взвешенного среднего с весами\n  let detectedLevel = 0;\n  let totalWeight = 0;\n\n  scores.forEach(([level, { confidence }]) => {\n    detectedLevel += level * confidence;\n    totalWeight += confidence;\n  });\n\n  if (totalWeight > 0) {\n    detectedLevel /= totalWeight;\n  }\n\n  return {\n    detectedLevel: Math.round(detectedLevel * 10) / 10,\n    confidence: topConfidence,\n    zone,\n    levelScoreDistribution: new Map(\n      scores.map(([level, { confidence }]) => [level, confidence])\n    ),\n  };\n}\n\n/**\n * Выбрать следующий вопрос на основе адаптивной логики\n */\nfunction selectNextQuestion(\n  state: AdaptiveTestState,\n  allQuestions: Map<string, SmartQuestion>\n): SmartQuestion | null {\n  const availableQuestions = Array.from(allQuestions.values()).filter(\n    (q) => !state.questionsAsked.has(q.id)\n  );\n\n  if (availableQuestions.length === 0) {\n    return null; // Нет больше вопросов\n  }\n\n  // ФАЗА ЗОНИРОВАНИЯ: задать все вопросы зонирования\n  if (state.currentPhase === 'zoning') {\n    const zoningQuestions = availableQuestions.filter((q) =>\n      [\n        'zone-conflict-001',\n        'zone-safety-002',\n        'zone-growth-003',\n        'zone-intimacy-004',\n        'zone-choice-005',\n        'zone-difference-006',\n      ].includes(q.id)\n    );\n\n    if (zoningQuestions.length > 0) {\n      // Вернуть первый оставшийся вопрос зонирования\n      return zoningQuestions[0];\n    }\n  }\n\n  // ФАЗА УТОЧНЕНИЯ: выбрать вопросы, специфичные для детектируемой зоны\n  if (state.currentPhase === 'refinement') {\n    if (!state.detectedZone) {\n      // Определить зону, если она еще не определена\n      const detection = detectCurrentLevel(state.answers, allQuestions);\n      state.detectedZone = detection.zone;\n    }\n\n    // Выбрать уровень на основе детектируемой зоны\n    let targetLevelRange: UnionLevel[];\n    if (state.detectedZone === 'low') {\n      targetLevelRange = [1, 2, 3, 4];\n    } else if (state.detectedZone === 'middle') {\n      targetLevelRange = [5, 6, 7, 8];\n    } else {\n      targetLevelRange = [9, 10, 11, 12];\n    }\n\n    // Получить текущее определение уровня\n    const detection = detectCurrentLevel(state.answers, allQuestions);\n\n    // Выбрать вопрос, который лучше всего разделяет уровни в целевом диапазоне\n    const refinementQuestions = availableQuestions.filter((q) => {\n      // Вопрос должен быть о уточнении, не о зонировании, не о валидации\n      const isRefinement =\n        q.id.startsWith('level-detail-') ||\n        q.id.startsWith('boundary-') ||\n        q.id.startsWith('autonomy-') ||\n        q.id.startsWith('understanding-') ||\n        q.id.startsWith('hope-');\n\n      if (!isRefinement) return false;\n\n      // Вопрос должен быть релевантен для целевого уровня\n      const overlapsWithTarget = q.targetLevels.some((level) =>\n        targetLevelRange.includes(level)\n      );\n\n      return overlapsWithTarget;\n    });\n\n    if (refinementQuestions.length > 0) {\n      // Выбрать приоритетный вопрос\n      const priorityQuestions = refinementQuestions.filter((q) => q.priority === 1);\n      return priorityQuestions.length > 0\n        ? priorityQuestions[0]\n        : refinementQuestions[0];\n    }\n  }\n\n  // ФАЗА ВАЛИДАЦИИ: задать вопросы валидации\n  if (state.currentPhase === 'validation') {\n    const validationQuestions = availableQuestions.filter(\n      (q) => q.isValidation === true\n    );\n\n    if (validationQuestions.length > 0) {\n      // Выбрать первый доступный вопрос валидации\n      return validationQuestions[0];\n    }\n  }\n\n  return null;\n}\n\n/**\n * Перейти к следующей фазе теста\n */\nfunction advancePhase(state: AdaptiveTestState): void {\n  if (state.currentPhase === 'zoning') {\n    // Проверить, все ли вопросы зонирования отвечены\n    const zoningQIds = [\n      'zone-conflict-001',\n      'zone-safety-002',\n      'zone-growth-003',\n      'zone-intimacy-004',\n      'zone-choice-005',\n      'zone-difference-006',\n    ];\n\n    const zoningAnswered = state.answers.filter((a) =>\n      zoningQIds.includes(a.questionId)\n    ).length;\n\n    if (zoningAnswered >= 6) {\n      state.currentPhase = 'refinement';\n    }\n  } else if (state.currentPhase === 'refinement') {\n    // Перейти к валидации после 8-12 вопросов уточнения\n    const refinementCount = state.answers.length - 6; // Минус вопросы зонирования\n\n    if (refinementCount >= 8) {\n      state.currentPhase = 'validation';\n    }\n  } else if (state.currentPhase === 'validation') {\n    // Завершить после 3-4 вопросов валидации\n    const validationCount = state.answers.length - 6 - 8; // Минус предыдущие фазы\n\n    if (validationCount >= 3) {\n      state.currentPhase = 'complete';\n    }\n  }\n}\n\n// ============================================================================\n// ПУБЛИЧНЫЙ API\n// ============================================================================\n\n/**\n * Получить следующий вопрос для пользователя\n */\nexport function getNextQuestion(\n  state: AdaptiveTestState\n): QuestionSelection | null {\n  // Преобразовать в Map для удобства\n  const questionsMap = new Map<string, SmartQuestion>();\n  QUESTIONS.forEach((q) => questionsMap.set(q.id, q));\n\n  // Выбрать следующий вопрос\n  const nextQuestion = selectNextQuestion(state, questionsMap);\n\n  if (!nextQuestion) {\n    // Перейти к следующей фазе если нет вопросов в текущей\n    advancePhase(state);\n\n    if (state.currentPhase === 'complete') {\n      return null; // Тест завершен\n    }\n\n    // Попробовать выбрать вопрос из новой фазы\n    const nextQuestionRetry = selectNextQuestion(state, questionsMap);\n    if (!nextQuestionRetry) {\n      return null; // Нет больше вопросов\n    }\n\n    return createQuestionSelection(state, nextQuestionRetry, questionsMap);\n  }\n\n  return createQuestionSelection(state, nextQuestion, questionsMap);\n}\n\n/**\n * Записать ответ пользователя\n */\nexport function recordAnswer(\n  state: AdaptiveTestState,\n  answer: UserAnswer\n): void {\n  state.answers.push(answer);\n  state.questionsAsked.add(answer.questionId);\n  state.questionsAnswered++;\n\n  // Попробовать перейти к следующей фазе если нужно\n  advancePhase(state);\n}\n\n/**\n * Получить текущую оценку уровня\n */\nexport function getCurrentLevelDetection(\n  state: AdaptiveTestState\n): LevelDetection {\n  const questionsMap = new Map<string, SmartQuestion>();\n  QUESTIONS.forEach((q) => questionsMap.set(q.id, q));\n\n  return detectCurrentLevel(state.answers, questionsMap);\n}\n\n/**\n * Завершить тест и получить финальный результат\n */\nexport function completeTest(\n  state: AdaptiveTestState\n): {\n  finalLevel: LevelDetection;\n  totalQuestionsAnswered: number;\n  totalTimeMs: number;\n} {\n  const questionsMap = new Map<string, SmartQuestion>();\n  QUESTIONS.forEach((q) => questionsMap.set(q.id, q));\n\n  const finalLevel = detectCurrentLevel(state.answers, questionsMap);\n\n  return {\n    finalLevel,\n    totalQuestionsAnswered: state.questionsAnswered,\n    totalTimeMs: Date.now() - state.testStartTime,\n  };\n}\n\n// ============================================================================\n// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ\n// ============================================================================\n\n/**\n * Создать объект QuestionSelection\n */\nfunction createQuestionSelection(\n  state: AdaptiveTestState,\n  question: SmartQuestion,\n  questionsMap: Map<string, SmartQuestion>\n): QuestionSelection {\n  const estimatedLevel =\n    state.questionsAnswered > 0\n      ? getCurrentLevelDetection(state)\n      : undefined;\n\n  return {\n    nextQuestion: question,\n    phase: state.currentPhase,\n    questionsAnswered: state.questionsAnswered,\n    questionsRemaining: 28 - state.questionsAnswered, // Максимум 28 вопросов\n    estimatedLevelSoFar: estimatedLevel,\n  };\n}\n"
